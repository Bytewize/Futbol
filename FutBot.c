#pragma config(Sensor, S1,     Cam,            sensorCustom)
#pragma config(Sensor, S2,     Ball,           sensorLightActive)
#pragma config(Motor,  motorA,          tmotorNormal,  tmotorNormal, openLoop)
#pragma config(Motor,  motorB,          tmotorNormal,  tmotorNormal, openLoop)
#pragma config(Motor,  motorC,          tmotorNormal,  tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "TriWheel.c"// Scanner task and functions
#include "nxtcamlib.c"

int nblobs;  // Number of blobs
int Balls, GateAs;
int_array bc, bl, bt, br, bb;
int_array Bbl, Bbt, Bbr, Bbb;
int_array Gbl, Gbt, Gbr, Gbb;
int x_centre, x_error;
int y_centre, y_error;
bool erased = false;
int state = 0;
int Height, Width, Area;
//int i, n, width, height;
task main()
{
  init_camera(Cam);
  StartTask (TriWheel);
  while(true)
  {
    if(nNxtButtonPressed == 3)
      state = 0;

    get_blobs(Cam, nblobs, bc, bl, bt, br, bb);
    Balls = 0;
    GateAs = 0;
    for(int i = 0; i < nblobs; i++)
    {
      Height = abs(bb[0] - bt[0]);
      Width = abs(bl[0] - br[0]);
      Area = Height * Width;
      if(Area > 100)
      {
        if(bc[i] == 0)
        {
          Bbl[Balls] = bl[i];
          Bbt[Balls] = bt[i];
          Bbr[Balls] = br[i];
          Bbb[Balls] = bb[i];
          Balls++;
        }
        if(bc[i] == 1)
        {
          Gbl[GateAs] = bl[i];
          Gbt[GateAs] = bt[i];
          Gbr[GateAs] = br[i];
          Gbb[GateAs] = bb[i];
          GateAs++;
        }
      }
    }
    switch(state)
    {

    case 0:// wait for start
      scan = false;
      Vx = 0;
      Vy = 0;
      if(nNxtButtonPressed == 2)
        state++;
      break;


    case 1://find ball
      if (Balls > 0)
      {
        state++;
        break;
      }
      scan = true;
      Vx = 0;
      Vy = 0;
      break;


    case 2://chase ball
      scan = false;

      if (Balls < 1)
      {
        state--;
        break;
      }

      if(SensorValue[Ball] > 55)
      {
        state++;
        break;
      }

      // Find the centre of the blob using double resolution of camera
      x_centre = Bbl[0] + Bbr[0];
      y_centre = Bbt[0] + Bbb[0];
      Height = abs(Bbb[0] - Bbt[0]);
      Width = abs(Bbl[0] - Bbr[0]);
      Area = Height * Width;
      // Compute the error from the desired position of the blob (using double resolution)
      x_error = 176 - x_centre;
      //y_error = 143 - y_centre;


        scan = false;
        if(x_error > 100)
          x_error = 100;
        if(x_error < -100)
          x_error = -100;

        Vx = x_error;

        if(x_error > 0)
          lastside = false;
        else
          lastside = true;

        Vy = -100;
        // Vy =  -bt[0] * 2;
        wait1Msec(300);
      break;


    case 3://caught ball, find gate
      if (GateAs > 0)
      {
        state++;
        break;
      }
      scan = true;
      Vx = 0;
      Vy = 0;
      break;


    case 4://dump at gate
      scan = false;

      if (GateAs < 1)
      {
        scan = true;
        state--;
        break;
      }
      scan = false;

      if(SensorValue[Ball] < 55)//lost ball, find again
      {
        state = 1;
        break;
      }

      // Find the centre of the blob using double resolution of camera
      x_centre = Gbl[0] + Gbr[0];
      y_centre = Gbt[0] + Gbb[0];
      Height = abs(Gbb[0] - Gbt[0]);
      Width = abs(Gbl[0] - Gbr[0]);
      Area = Height * Width;
      // Compute the error from the desired position of the blob (using double resolution)
      x_error = 176 - x_centre;
      //y_error = 143 - y_centre;

        if(Area > 5000)
        {
          Vx = 0;
          Vy = 0;
          state++;
          break;
      }

      if(x_error > 100)
        x_error = 100;
      if(x_error < -100)
        x_error = -100;

      Vx = x_error;

      if(x_error > 0)
        lastside = false;
      else
        lastside = true;

      Vy = -100;
      // Vy =  -bt[0] * 2;
      wait1Msec(300);

      break;


    case 5://deposit at gate
      state = 0;
      break;

    }

    nxtDisplayTextLine(0,"color1 %d",bc[0]);
    nxtDisplayTextLine(1,"color2 %d",bc[1]);
    nxtDisplayTextLine(2,"Top %d",bt[0]);
    nxtDisplayTextLine(3,"Bottom %d",bb[0]);
    nxtDisplayTextLine(4,"Area %d",Area);
    nxtDisplayTextLine(5,"Height %d",Height);
    nxtDisplayTextLine(6,"X err %d",x_error);


  }
}
